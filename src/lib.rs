// MIT License
//
// Copyright (c) 2018 Kevin Kirchner
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//! `cve-get` is a library and command line program for fetching CVE information
//! from the web written entirely in Rust.

extern crate chrono;
extern crate curl;
extern crate serde_json;
extern crate serde;

#[macro_use]
extern crate serde_derive;

use chrono::{DateTime, Utc};
use serde::{Deserialize, Deserializer};
use serde::de::Error as DeError;
use std::fmt;
use std::str::FromStr;
use std::result::Result as StdResult;

mod errors;
mod downloader;
use errors::{Result, Error};

/// Static base URL to the web API
static BASE_URL: &'static str = "https://cve.circl.lu/api";


fn str_to_f32<'de, D>(deserializer: D) -> StdResult<Option<f32>, D::Error>
    where D: Deserializer<'de> {
    match String::deserialize(deserializer) {
        Err(_)  => Ok(None),
        Ok(v)   => match f32::from_str(&v) {
            Ok(v)   => Ok(Some(v)),
            Err(_)  => Ok(None)
        }
    }
}

fn from_string<'de, T, D>(deserializer: D) -> StdResult<T, D::Error>
    where T: FromStr, T::Err: fmt::Display, D: Deserializer<'de> {
    let s = String::deserialize(deserializer)?;
    T::from_str(&s).map_err(DeError::custom)
}

/// Manually deserializes the struct `VulnerableConfiguration`. This is
/// necessary, because for some API calls the data contains the full struct with
/// CPE and human readable representation, but for the `query` call it returns a
/// vector of CPEs only.
fn de_vuln_configs<'de, D>(deserializer: D) -> StdResult<Vec<VulnerableConfiguration>, D::Error>
    where D: Deserializer<'de> {
    let val = serde_json::Value::deserialize(deserializer)?;
    if val.is_null() && !val.is_array() {
        return Ok(Vec::new());
    }

    let val = val.as_array().unwrap();
    if val.len() <= 0 {
        return Ok(Vec::new());
    }

    let mut result: Vec<VulnerableConfiguration> = Vec::new();
    for element in val.into_iter() {
        if element.is_string() {
            result.push(VulnerableConfiguration {
                id: element.to_string(), title: None
            });
        } else if element.is_object() {
            let element = element.as_object().unwrap();
            let id = element.get("id");
            let id = match id {
                None    => {return Err(DeError::missing_field("id"))},
                Some(v) => {
                    if !v.is_string() {
                        return Err(DeError::custom("The field 'id' must be of type 'String'!"));
                    }
                    v.as_str().unwrap().to_owned()
                },
            };
            let title = element.get("title").and_then(|s|
                s.as_str().map(|x| x.to_owned()));
            result.push(VulnerableConfiguration {id: id, title: title});
        }
    }
    Ok(result)
}

/// Module for custom date time so serde can automatically deserialize
/// timestamps in CVEs
mod custom_datetime {

    use chrono::{DateTime, Utc, TimeZone};
    use serde::{self, Deserializer, Deserialize};

    const FORMAT: &'static str = "%Y-%m-%dT%H:%M:%S%.6f";

    pub fn deserialize<'de, D>(deserializer: D) -> Result<DateTime<Utc>, D::Error>
        where D: Deserializer<'de> {
        let s = String::deserialize(deserializer)?;
        Utc.datetime_from_str(&s, FORMAT).map_err(serde::de::Error::custom)
    }

}

/// A trait for structures that may print different amounts of information for
/// `fmt::Display` and `FullPrintable`.
pub trait FullPrintable {
    /// Returns a full string representation of the object as `String.`
    fn full_string(&self) -> String;
}

/// Enumeration of modifiers to filter CVSSs
#[derive(Debug)]
pub enum CVSSModifier {
    /// Value must be greater than a specific threshold
    Above,
    /// Values must be equal
    Equal,
    /// Value must be lower than a specific threshold
    Below
}

impl fmt::Display for CVSSModifier {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match *self {
            CVSSModifier::Above => write!(f, "above"),
            CVSSModifier::Equal => write!(f, "equals"),
            CVSSModifier::Below => write!(f, "below"),
        }
    }
}

/// Struct holding various options for filtering CVEs
#[derive(Debug)]
pub struct QueryOptions {
    /// Whether to show rejected CVEs (`true` -> show, `false` -> hide)
    pub rejected: bool,
    /// Optionally filter by CVSS score
    pub cvss_score: Option<f32>,
    /// The modifier to apply when comparing CVSS scores to `cvss_score'
    pub cvss_modifier: CVSSModifier,
    /// Optionally skip the first `skip` results
    pub skip: Option<usize>,
    /// Optionally limit the number of returned CVEs
    pub limit: Option<usize>,
}

impl QueryOptions {
    /// Creates a new instance of `QueryOptions`. By default, the options will
    /// show all CVEs (`rejected` is `true`), but will not apply any other
    /// filters (optional members are `None`). The default `cvss_modifier` is
    /// `CVSSModifier::Above`.
    pub fn new() -> QueryOptions {
        QueryOptions {
            rejected: true, cvss_score: None,
            cvss_modifier: CVSSModifier::Above, skip: None, limit: None
        }
    }
}

/// Structure representing a vendor and his products
#[derive(Debug, Deserialize)]
pub struct Vendor {
    /// The vendor's name
    #[serde(rename = "vendor")]
    pub name: String,
    /// List of products by this vendor
    #[serde(default, rename = "product")]
    pub products: Vec<String>,
}

impl fmt::Display for Vendor {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{} ({} products)", self.name, self.products.len())
    }
}

impl FullPrintable for Vendor {
    fn full_string(&self) -> String {
        let mut result = String::new();
        result.push_str(&format!("{}\n", self));
        for item in self.products.iter() {
            result.push_str(&format!("\t{}\n", item));
        }
        result
    }
}

/// A structure representing a list of vendors
#[derive(Deserialize)]
struct VendorList {
    /// List of vendors
    #[serde(rename = "vendor")]
    vendor_list: Vec<String>
}

/// Represents a single CWE (Common Weakness Enumeration)
#[derive(Debug, Deserialize)]
pub struct CWE {
    /// ID number of this CWE
    #[serde(deserialize_with = "from_string")]
    pub id: u32,
    /// Descriptive name of the CWE
    pub name: String,
    /// Current status of the CWE
    pub status: String,
    /// Description of this CWE
    #[serde(rename = "description_summary")]
    pub description: String,
}

impl fmt::Display for CWE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CWE {}", self.id)
    }
}

impl FullPrintable for CWE {
    fn full_string(&self) -> String {
        format!("CWE {}\nName: {}\nStatus: {}\nDescription: {}", self.id,
            self.name, self.status, self.description)
    }
}

/// Represents a single vulerable configuration (device, software, ...)
#[derive(Debug, Deserialize)]
pub struct VulnerableConfiguration {
    /// ID string for this configuration (CPE ID)
    pub id: String,
    /// Human friendly name of this configuration (optional)
    #[serde(default)]
    pub title: Option<String>,
}

impl fmt::Display for VulnerableConfiguration {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.id)
    }
}

impl FullPrintable for VulnerableConfiguration {
    fn full_string(&self) -> String {
        match (*self).title {
            None        => self.id.to_string(),
            Some(ref v) => format!("{} ({})", v, self.id)
        }
    }
}

/// Holds details about a particular CVE
#[derive(Debug, Deserialize)]
pub struct CVE {
    /// Date and time of last modification
    #[serde(rename = "Modified", with = "custom_datetime")]
    pub modified: DateTime<Utc>,
    /// Date and time of publication
    #[serde(rename = "Published", with = "custom_datetime")]
    pub published: DateTime<Utc>,
    /// ID of this CVE
    pub id: String,
    /// List of external references with more information
    pub references: Vec<String>,
    /// Summary/description of this CVE
    pub summary: String,
    /// CVSS score if available
    #[serde(default, deserialize_with = "str_to_f32")]
    pub cvss: Option<f32>,
    /// List of affected configurations
    #[serde(default, rename = "vulnerable_configuration", deserialize_with = "de_vuln_configs")]
    pub configs: Vec<VulnerableConfiguration>,
}

impl fmt::Display for CVE {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "{}", self.id)
    }
}

impl FullPrintable for CVE {
    fn full_string(&self) -> String {
        let mut result = format!(
            "{}\nPublished: {}\nLast modified: {}\nCVSS Score: {}\nSummary: {}",
            self.id, self.published, self.modified, match self.cvss {
                None => String::from("None"), Some(v) => v.to_string()
            }, self.summary
        );
        result.push_str("References:\n");
        for item in self.references.iter() {
            result.push_str(&format!("\t-{}\n", item));
        }
        result.push_str("Affected configurations:\n");
        for item in self.configs.iter() {
            result.push_str(&format!("\t-{}\n", item));
        }
        result
    }
}

/// Makes a generic API call with optional parameters and returns the response.
/// The call itself must not be empty. If no parameters are specified, the
/// requested URL will be of the form "BASE_URL/api_call". If there are
/// parameters, they will simply be appended ("BASE_URL/api_call/params").
///
/// # Arguments
///
/// * `api_call` - The requested API call as string (must not be empty)
/// * `params` - Optional parameters for the API call
///
/// # Errors
///
/// The function will return an error if:
/// * `api_call` is an empty string
/// * a failure inside `libcurl` occurs
/// * the response data is not valid UTF8 data
/// * the response HTTP code is not 200
fn call<T>(api_call: &str, params: Option<T>, options: Option<&QueryOptions>) -> Result<String>
    where T: fmt::Display {
    if api_call.is_empty() {
        return Err(Error::InvalidArgument("api_call"));
    }

    let mut d = downloader::Downloader::new();

    if options.is_some() {
        let options = options.unwrap();
        if !options.rejected {
            d.headers_mut().set("rejected", "hide");
        }

        if options.cvss_score.is_some() {
            d.headers_mut().set("cvss_score", &options.cvss_score.unwrap().to_string());
            d.headers_mut().set("cvss_modifier", &options.cvss_modifier.to_string());
        }

        if options.limit.is_some() {
            d.headers_mut().set("limit", &options.limit.unwrap().to_string());
        }
        if options.skip.is_some() {
            d.headers_mut().set("skip", &options.skip.unwrap().to_string());
        }
    }

    let response = match params {
        Some(s) => d.download(&format!("{}/{}/{}", BASE_URL, api_call, s)),
        None    => d.download(&format!("{}/{}", BASE_URL, api_call)),
    }?;

    if response.0 != 200 {
        return Err(Error::BadResponseCode(response.0));
    }

    Ok(response.1)
}

impl CVE {
    /// This function returns the last CVEs. The number of CVEs returned is
    /// controlled by `count`. If `count` equals 0 no actual API request will be
    /// done. Instead, an empty vector will be returned.
    ///
    /// # Arguments
    ///
    /// * `count` - The number of CVEs to return
    ///
    /// # Errors
    ///
    /// The function will return an error if
    /// * a failure inside `libcurl` occurs
    /// * the response data is not valid UTF8 data
    /// * the response HTTP code is not 200
    /// * the reponse data could not be parsed as JSON
    pub fn last_n(count: usize) -> Result<Vec<CVE>> {
        if count <= 0 {
            return Ok(Vec::new());
        }

        let response = call("last", Some(count), None)?;
        let data: StdResult<Vec<CVE>, _> = serde_json::from_str(&response);
        data.map_err(Error::SerdeError)
    }

    /// This function returns the single last CVE by calling `last_n(1)` and
    /// returning the first and only element of the result vector.
    ///
    /// # Errors
    ///
    /// The function will return an error if
    /// * a failure inside `libcurl` occurs
    /// * the response data is not valid UTF8 data
    /// * the response HTTP code is not 200
    /// * the reponse data could not be parsed as JSON
    /// * the request did not return a single CVE
    pub fn last() -> Result<CVE> {
        let mut result = CVE::last_n(1)?;
        if result.len() != 1 {
            return Err(Error::GeneralError("The request did return a single CVE"));
        }
        Ok(result.pop().unwrap())
    }

    /// This function returns the a CVE by its ID. The CVE ID is a string of the
    /// form "CVE-<YEAR>-<NUMBER>".
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of CVE to return
    ///
    /// # Errors
    ///
    /// The function will return an error if
    /// * `id` is an empty string
    /// * the `id` is invalid (wrong format, unknown CVE, ...)
    /// * a failure inside `libcurl` occurs
    /// * the response data is not valid UTF8 data
    /// * the response HTTP code is not 200
    /// * the reponse data could not be parsed as JSON
    pub fn get(id: &str) -> Result<CVE> {
        if id.is_empty() {
            return Err(Error::InvalidArgument("id"));
        }

        let response = call("cve", Some(id), None)?;
        if response == "null" {
            return Err(Error::NotExisting);
        }

        let data: StdResult<CVE, _> = serde_json::from_str(&response);
        data.map_err(Error::SerdeError)
    }

    /// This function returns all CVEs that match the search options specified by
    /// `options` by using the API call `query`.
    ///
    /// # Arguments
    ///
    /// * `options` - The options to use for filtering the CVEs
    ///
    /// # Errors
    ///
    /// The function fails and returns an error if
    /// * a failure inside `libcurl` occurs
    /// * the response data is not valid UTF8 data
    /// * the response HTTP code is not 200
    /// * the reponse data could not be parsed as JSON
    pub fn query(options: &QueryOptions) -> Result<Vec<CVE>> {
        let response = call::<&str>("query", None, Some(options))?;
        if response.is_empty() {
            return Err(Error::GeneralError("The API call did not return any data!"));
        }

        let data: StdResult<Vec<CVE>, _> = serde_json::from_str(&response);
        data.map_err(Error::SerdeError)
    }

    /// Returns a list of CVEs that affect the specified combination of `vendor`
    /// and `product`. Both arguments must not be empty. If the given combination
    /// does not exist, the function returns an empty vector.
    ///
    /// # Arguments
    ///
    /// * `vendor` - The vendor of the product (must not be empty)
    /// * `product` - The name of the product (must not be empty)
    ///
    /// # Errors
    ///
    /// This function fails and returns an error if
    /// * either `vendor` or `product` or both are empty strings
    /// * a failure inside `libcurl` occurs
    /// * the response data is not valid UTF8 data
    /// * the response HTTP code is not 200
    /// * the reponse data could not be parsed as JSON
    pub fn get_by_product(vendor: &str, product: &str) -> Result<Vec<CVE>> {
        if vendor.is_empty() {
            return Err(Error::InvalidArgument("vendor"));
        }
        if product.is_empty() {
            return Err(Error::InvalidArgument("product"));
        }

        let response = call("search", Some(format!("{}/{}", vendor, product)), None)?;

        if response.is_empty() {
            return Ok(Vec::new());
        }

        let data: StdResult<Vec<CVE>, _> = serde_json::from_str(&response);
        data.map_err(Error::SerdeError)
    }
}

impl Vendor {

    /// Returns a list of all known products of `vendor`. The string describing
    /// the vendor must not be empty. If the vendor is known, but does not have
    /// any known products, the returned `VendorInfo` contains an empty list of
    /// products, but the request will still be successful.
    ///
    /// # Arguments
    ///
    /// * `vendor` - The vendor to get the products of (must not be empty)
    ///
    /// # Errors
    ///
    /// The function returns an error if
    /// * `vendor` is an empty string
    /// * a failure inside `libcurl` occurs
    /// * the response data is not valid UTF8 data
    /// * the response HTTP code is not 200
    /// * the reponse data could not be parsed as JSON
    pub fn products(vendor: &str) -> Result<Vendor> {
        if vendor.is_empty() {
            return Err(Error::InvalidArgument("vendor"));
        }

        let response = call("browse", Some(vendor), None)?;
        if response.is_empty() || response == "{}" {
            return Err(Error::NotExisting);
        }

        let data: StdResult<Vendor, _> = serde_json::from_str(&response);
        data.map_err(Error::SerdeError)
    }

    /// This function returns a list of all known vendors, where each vendor is
    /// represented by a simple `String`. The returned strings may be used to fetch
    /// the products of a specific vendor by calling `get_products` with the
    /// respective vendor name as argument.
    ///
    /// # Errors
    ///
    /// The function returns an error if
    /// * a failure inside `libcurl` occurs
    /// * the response data is not valid UTF8 data
    /// * the response HTTP code is not 200
    /// * the reponse data could not be parsed as JSON
    pub fn vendors() -> Result<Vec<String>> {
        let response = call::<&str>("browse", None, None)?;
        if response.is_empty() {
            return Err(Error::GeneralError("The API call did not return any data!"));
        }

        let data: VendorList = serde_json::from_str(&response)?;
        Ok(data.vendor_list)
    }
}

impl CWE {

    /// This function returns a list of all known CWEs (Common Weakness
    /// Enumeration).
    ///
    /// # Errors
    ///
    /// The function returns an error if
    /// * a failure inside `libcurl` occurs
    /// * the response data is not valid UTF8 data
    /// * the response HTTP code is not 200
    /// * the reponse data could not be parsed as JSON
    pub fn list() -> Result<Vec<CWE>> {
        let response = call::<&str>("cwe", None, None)?;
        if response.is_empty() {
            return Err(Error::GeneralError("The API call did not return any data!"));
        }

        let data: StdResult<Vec<CWE>, _> = serde_json::from_str(&response);
        data.map_err(Error::SerdeError)
    }

    /// Tries to find the CWE with the ID `id` and returns it. Returns `None` if
    /// the CWE could not be found or if an error occurred while retrieving or
    /// parsing the data.
    ///
    /// # Arguments
    ///
    /// * `id` - The ID of the CWE to get
    ///
    /// # Notes
    ///
    /// The web API of circl.lu currently does not provide a function to
    /// directly fetch a specific CWE by its ID. Therefore, this function first
    /// retrieves a list of CWEs using the `list()`-function and tries to find
    /// a CWE with the specified ID in the returned list.
    pub fn get(id: u32) -> Option<CWE> {
        match CWE::list() {
            Err(_)  => None,
            Ok(v)   => {
                for element in v.into_iter() {
                    if element.id == id {
                        return Some(element);
                    }
                }
                None
            },
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn deserialization_success() {
        let data = r#"{
            "Modified": "2018-05-19T14:29:00.227000",
            "Published": "2018-05-19T14:29:00.227000",
            "cvss": null,
            "id": "CVE-2018-11239",
            "last-modified": "2018-05-19T14:29:00.227000",
            "references": [
                "https://peckshield.com/2018/05/18/burnOverflow/"
            ],
            "summary": "An integer overflow in the _transfer function of a smart contract implementation for Hexagon (HXG), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized increase of digital assets by providing a _to argument in conjunction with a large _value argument, as exploited in the wild in May 2018, aka the \"burnOverflow\" issue.",
            "vulnerable_configuration": [
                {
                    "id": "cpe:2.3:o:linux:linux_kernel:3.3",
                    "title": "Linux Kernel 3.3"
                },
                {
                    "id": "cpe:2.3:o:linux:linux_kernel:3.3:rc1",
                    "title": "Linux Kernel 3.3 release candidate 1"
                }
            ],
            "vulnerable_configuration_cpe_2_2": []
        }"#;
        let obj: CVE = serde_json::from_str(data).unwrap();
        assert_eq!(obj.cvss, None);
        assert_eq!(obj.modified.to_string(), "2018-05-19 14:29:00.227 UTC");
        assert_eq!(obj.published.to_string(), "2018-05-19 14:29:00.227 UTC");
        assert_eq!(obj.id, "CVE-2018-11239");
        assert_eq!(obj.references.len(), 1);
        assert_eq!(obj.references[0], "https://peckshield.com/2018/05/18/burnOverflow/");
        assert!(!obj.summary.is_empty());
        assert_eq!(obj.configs.len(), 2);
    }

    #[test]
    fn deserialization_failure_missing() {
        let data = r#"{
            "Modified": "2018-05-19T14:29:00.227000",
            "cvss": null,
            "last-modified": "2018-05-19T14:29:00.227000",
            "references": [
                "https://peckshield.com/2018/05/18/burnOverflow/"
            ],
            "summary": "An integer overflow in the _transfer function of a smart contract implementation for Hexagon (HXG), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized increase of digital assets by providing a _to argument in conjunction with a large _value argument, as exploited in the wild in May 2018, aka the \"burnOverflow\" issue.",
            "vulnerable_configuration": [],
            "vulnerable_configuration_cpe_2_2": []
        }"#;
        let obj: StdResult<CVE, _> = serde_json::from_str(data);
        assert!(obj.is_err());
    }

    #[test]
    fn deserialization_failure_invalid_type() {
        let data = r#"{
            "Modified": 42,
            "Published": "2018-05-19T14:29:00.227000",
            "cvss": null,
            "id": "CVE-2018-11239",
            "last-modified": "2018-05-19T14:29:00.227000",
            "references": [
                "https://peckshield.com/2018/05/18/burnOverflow/"
            ],
            "summary": "An integer overflow in the _transfer function of a smart contract implementation for Hexagon (HXG), an Ethereum ERC20 token, allows attackers to accomplish an unauthorized increase of digital assets by providing a _to argument in conjunction with a large _value argument, as exploited in the wild in May 2018, aka the \"burnOverflow\" issue.",
            "vulnerable_configuration": [],
            "vulnerable_configuration_cpe_2_2": []
        }"#;
        let obj: StdResult<CVE, _> = serde_json::from_str(data);
        assert!(obj.is_err());
    }

    #[test]
    #[ignore]
    fn get_last_cve() {
        let x = CVE::last_n(0);
        assert!(x.is_ok());
        assert_eq!(x.unwrap().len(), 0);
        let x = CVE::last_n(1);
        assert!(x.is_ok());
        assert_eq!(x.unwrap().len(), 1);
        let x = CVE::last();
        assert!(x.is_ok());
        let x = CVE::last_n(3);
        assert!(x.is_ok());
        assert_eq!(x.unwrap().len(), 3);
    }

    #[test]
    #[ignore]
    fn get_by_id_success() {
        let x = CVE::get("CVE-2017-0781");
        assert!(x.is_ok());
        let x = x.unwrap();
        assert_eq!(x.id, "CVE-2017-0781");
        assert_eq!(x.published.to_string(), "2017-09-14 15:29:00.190 UTC");
        assert_eq!(x.cvss.unwrap(), 8.3);
        assert_eq!(x.references.len(), 4);
        assert_eq!(x.configs.len(), 30);
    }

    #[test]
    #[ignore]
    fn get_by_id_failure() {
        let x = CVE::get("CVE-2017-1234567890");
        assert!(x.is_err());
        assert_eq!(format!("{}", x.err().unwrap()), "NotExisting");

        let x = CVE::get("");
        assert!(x.is_err());
        assert_eq!(format!("{}", x.err().unwrap()), "InvalidArgument: id");

        let x = CVE::get("2017-0781");
        assert!(x.is_err());
        assert_eq!(format!("{}", x.err().unwrap()), "NotExisting");
    }

    #[test]
    fn deserialize_products() {
        let data = r#"
        {
            "product": [
                "9gag_-_funny_pics_and_videos"
            ],
            "vendor": "9gag"
        }"#;
        let x: StdResult<Vendor, _> = serde_json::from_str(data);
        assert!(x.is_ok());
        let x = x.unwrap();
        assert_eq!(x.name, "9gag");
        assert_eq!(x.products.len(), 1);

        let data = r#"
        {
            "product": [
            ],
            "vendor": "9gag"
        }"#;
        let x: StdResult<Vendor, _> = serde_json::from_str(data);
        assert!(x.is_ok());
        let x = x.unwrap();
        assert_eq!(x.name, "9gag");
        assert_eq!(x.products.len(), 0);

        let data = r#"
        {
            "vendor": "9gag"
        }"#;
        let x: StdResult<Vendor, _> = serde_json::from_str(data);
        assert!(x.is_ok());
        let x = x.unwrap();
        assert_eq!(x.name, "9gag");
        assert_eq!(x.products.len(), 0);

        let data = r#"
        {
            "product": [
                "7-zip",
                "7zip",
                "p7zip"
            ],
            "vendor": "7-zip"
        }"#;
        let x: StdResult<Vendor, _> = serde_json::from_str(data);
        assert!(x.is_ok());
        let x = x.unwrap();
        assert_eq!(x.name, "7-zip");
        assert_eq!(x.products.len(), 3);
        assert_eq!(format!("{}", x), "7-zip (3 products)");
    }

    #[test]
    fn deserialize_products_failure() {
        let data = r#"
        {
            "product": [
                "7-zip",
                "7zip",
                "p7zip"
            ],
            "vend": "7-zip"
        }"#;
        let x: StdResult<Vendor, _> = serde_json::from_str(data);
        assert!(x.is_err());
    }

    #[test]
    #[ignore]
    fn get_products_success() {
        let result = Vendor::products("9gag");
        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result.name, "9gag");
        assert_eq!(result.products.len(), 1);
    }

    #[test]
    #[ignore]
    fn get_products_failure() {
        let result = Vendor::products("foobar");
        assert!(result.is_err());
    }

    #[test]
    #[ignore]
    fn get_vendors_success() {
        let result = Vendor::vendors();
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.len() > 1);
    }

    #[test]
    #[ignore]
    fn get_all_cwes() {
        let result = CWE::list();
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.len() > 1);
        assert!(!result[0].description.is_empty());
    }

    #[test]
    #[ignore]
    fn get_cwe_by_id_success() {
        let result = CWE::get(5);
        assert!(result.is_some());
        let result = result.unwrap();
        assert_eq!(result.id, 5);
        assert_eq!(result.name, "J2EE Misconfiguration: Data Transmission Without Encryption");
        assert_eq!(result.status, "Draft");
    }

    #[test]
    #[ignore]
    fn get_cwe_by_id_failure() {
        let result = CWE::get(1234567890);
        assert!(result.is_none());
    }

    #[test]
    #[ignore]
    fn query_test() {
        let mut options = QueryOptions::new();
        options.limit = Some(2);
        let result = CVE::query(&options);
        assert!(result.is_ok());
        assert_eq!(result.unwrap().len(), 2);

        options.cvss_score = Some(10.0);
        options.limit = Some(10);
        options.cvss_modifier = CVSSModifier::Equal;
        let result = CVE::query(&options);
        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result.len(), 10);
        assert_eq!(result[0].cvss.unwrap_or(10.0), 10.0);

        options.skip = Some(5);
        let result = CVE::query(&options);
        assert!(result.is_ok());
        let result = result.unwrap();
        assert_eq!(result.len(), 10);
    }

    #[test]
    #[ignore]
    fn test_by_product_success() {
        let result = CVE::get_by_product("microsoft", "excel");
        assert!(result.is_ok());
        let result = result.unwrap();
        assert!(result.len() >= 1);
    }

    #[test]
    #[ignore]
    fn test_by_product_failure() {
        let result = CVE::get_by_product("foo", "bar");
        assert!(result.is_ok());
        assert_eq!(result.unwrap().len(), 0);
    }
}
