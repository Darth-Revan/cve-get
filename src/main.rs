// MIT License
//
// Copyright (c) 2018 Kevin Kirchner
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

//! `cve-get` is a library and command line program for fetching CVE information
//! from the web written entirely in Rust.

extern crate clap;
extern crate libcveget;

use clap::*;
use std::error::Error;
use std::fmt;
use libcveget as cve;
use std::process::exit;

fn print_list<T>(list: cve::errors::Result<Vec<T>>, full: bool, title: Option<&str>)
    where T: cve::FullPrintable + fmt::Display {

    match list {
        Err(e)  => eprintln!("Error: {}", e.description()),
        Ok(l)   => {
            if title.is_some() {
                println!("{} ({} items)", title.unwrap_or(""), l.len());
            }
            for item in l.iter() {
                println!("\t- {}", if full { item.full_string() } else { item.to_string() });
            }
        }
    }
}

fn print<T>(element: cve::errors::Result<T>, full: bool)
    where T: cve::FullPrintable + fmt::Display {

    match element {
        Err(e)  => eprintln!("Error: {}", e.description()),
        Ok(e)   => {
            println!("{}", if full { e.full_string() } else { e.to_string() });
        }
    }
}

fn main() {
    let matches = App::new("cve-get")
        .version("1.0")
        .author("Kevin Kirchner <S1610304005@students.fh-hagenberg.at>")
        .about("Command line application to fetch CVE information from https://cve.circl.lu")
        .setting(AppSettings::ArgRequiredElseHelp)
        .subcommand(SubCommand::with_name("vendors")
            .about("Lists all vendors known to the CVE database")
        ).subcommand(SubCommand::with_name("products")
            .about("Lists all products by a specific vendor known to the CVE database")
            .arg(Arg::with_name("vendor")
                .takes_value(true)
                .required(true)
                .help("Name of the vendor to list the products of")
            )
        ).subcommand(SubCommand::with_name("cve")
            .about("Prints details of CVEs")
            .setting(AppSettings::SubcommandRequired)
            .subcommand(SubCommand::with_name("id")
                .about("Print details of a CVE by ID")
                .arg(Arg::with_name("id")
                    .takes_value(true)
                    .required(true)
                    .help("The ID of the CVE to fetch details of")
                )
            )
            .subcommand(SubCommand::with_name("last")
                .about("Prints the last few CVEs")
                .arg(Arg::with_name("count")
                    .takes_value(true)
                    .required(false)
                    .default_value("1")
                    .help("Number of the CVEs to fetch")
                )
                .arg(Arg::with_name("full")
                    .long("full")
                    .short("f")
                    .help("Print full CVE information for the last CVEs")
                )
            )
        ).subcommand(SubCommand::with_name("cwe")
            .about("Prints details of CWEs")
            .setting(AppSettings::SubcommandRequired)
            .subcommand(SubCommand::with_name("id")
                .about("Print information about a specific CWE")
                .arg(Arg::with_name("id")
                    .takes_value(true)
                    .required(true)
                    .help("ID of the CWE to print")
                )
            )
            .subcommand(SubCommand::with_name("list")
                .about("List all known subcommands")
                .arg(Arg::with_name("full")
                    .long("full")
                    .short("f")
                    .help("Print full CVE information for the last CVEs")
                )
            )
        ).subcommand(SubCommand::with_name("browse")
            .about("Browse list of CVEs with query options")
            .arg(Arg::with_name("full")
                .long("full")
                .short("f")
                .help("Print full CVE information for CVEs instead of just their IDs")
            )
            .arg(Arg::with_name("rejected")
                .long("hide-rejected")
                .takes_value(false)
                .help("Hide rejected CVEs (will be shown by default)")
            ).arg(Arg::with_name("score")
                .long("score")
                .short("s")
                .takes_value(true)
                .help("CVSS to compare with")
            ).arg(Arg::with_name("modifier")
                .long("modifier")
                .short("m")
                .takes_value(true)
                .possible_values(&["below", "equal", "above"])
                .default_value("equal")
                .help("Modifier for comparing CVSS scores (requires --score)")
            ).arg(Arg::with_name("skip")
                .value_name("COUNT")
                .long("skip")
                .takes_value(true)
                .help("Skip the first COUNT results and don't print them")
            ).arg(Arg::with_name("limit")
                .value_name("LIMIT")
                .long("limit")
                .short("l")
                .takes_value(true)
                .help("Limit the results to LIMIT items")
            )
        ).get_matches();

    // Handler for "vendor" subcommand
    if let Some(_) = matches.subcommand_matches("vendors") {
        print_list(cve::Vendor::vendors(), true, Some("List of known vendors:"));
        exit(0);
    }

    // Handler for "products" subcommand
    if let Some(matches) = matches.subcommand_matches("products") {
        let vendor = matches.value_of("vendor").unwrap_or("");
        match cve::Vendor::products(vendor) {
            Err(e)  => eprintln!("Error: {}", e.description()),
            Ok(val) => print_list(Ok(val.products), true, Some(&format!("Products by {}", val.name))),
        }
        exit(0);
    }

    // Handler for "cve" subcommand
    if let Some(matches) = matches.subcommand_matches("cve") {
        if let Some(matches) = matches.subcommand_matches("id") {
            print(cve::CVE::get(matches.value_of("id").unwrap_or("")), true);
        }

        if let Some(matches) = matches.subcommand_matches("last") {
            let count: usize = value_t_or_exit!(matches, "count", usize);
            print_list(cve::CVE::last_n(count), matches.is_present("full"), Some("Last CVEs"));
        }
        exit(0);
    }

    // Handler for "cwe" subcommand
    if let Some(matches) = matches.subcommand_matches("cwe") {
        if let Some(matches) = matches.subcommand_matches("id") {
            let id: u32 = value_t_or_exit!(matches, "id", u32);
            print(cve::CWE::get(id), true);
        }

        if let Some(matches) = matches.subcommand_matches("list") {
            print_list(cve::CWE::list(), matches.is_present("full"), Some("List of all CWEs"));
        }
        exit(0);
    }

    // Handler for "browse" subcommand
    if let Some(matches) = matches.subcommand_matches("browse") {
        let mut options = cve::QueryOptions::new();
        options.rejected = !matches.is_present("rejected");

        options.cvss_modifier = match matches.value_of("modifier").unwrap_or("") {
            "below" => cve::CVSSModifier::Below,
            "equal" => cve::CVSSModifier::Equal,
            _       => cve::CVSSModifier::Above,
        };

        if matches.is_present("score") {
            options.cvss_score = Some(value_t_or_exit!(matches, "score", f32));
        }

        if matches.is_present("skip") {
            options.skip = Some(value_t_or_exit!(matches, "skip", usize));
        }

        if matches.is_present("limit") {
            options.limit = Some(value_t_or_exit!(matches, "limit", usize));
        }

        print_list(cve::CVE::query(&options), matches.is_present("full"), Some("CVEs by filter options"));
        exit(0);
    }
}
