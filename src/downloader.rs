// MIT License
//
// Copyright (c) 2018 Kevin Kirchner
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE

//! This module is a wrapper around libcurl and can be used to download webpages
//! in order to use the web-based API of https://cve.circl.lu.

use errors::{Result, Error};
use curl;
use curl::easy::{Easy, List};
use std::collections::HashMap;
use std::str;

/// Structure for handling HTTP headers in requests
pub struct HttpHeaders {
    /// Internal hash map for storing headers
    internal: HashMap<String, String>
}

impl HttpHeaders {

    /// Initializes a new set of HTTP headers
    pub fn new() -> HttpHeaders {
        HttpHeaders {internal: HashMap::new()}
    }

    /// Sets the header `key` to `value`.
    ///
    /// If the header is not present in the structure, it will be added.
    /// Otherwise the header will be updated.
    ///
    /// # Arguments
    /// * `key` - The name of the header to be set
    /// * `value` - The value of the header
    pub fn set(&mut self, key: &str, value: &str) {
        self.internal.insert(String::from(key), String::from(value));
    }

    /// Returns the current state of headers as a list suitable for usage in
    /// `curl`.
    ///
    /// Simply creates a new `curl::easy::List`, adds all headers and returns
    /// the resulting list. If the operation fails, an instance of
    /// `CVEError::CurlError` will be returned.
    ///
    /// # Errors
    /// Returns an error if the underlying operation in `curl` fails.
    pub fn get_list(&self) -> Result<List> {
        let mut list = List::new();
        for (k, v) in &self.internal {
            list.append(&format!("{}: {}", k, v))?;
        }
        Ok(list)
    }
}

/// Structure for downloading webpages over HTTP(S)
pub struct Downloader {
    /// Underlying curl handle
    handle: Easy,
    /// Headers to be sent with each request
    header: HttpHeaders,
}

impl Downloader {

    /// Creates a new downloader.
    pub fn new() -> Downloader {
        let mut curl = Easy::new();
        curl.follow_location(true).unwrap();
        Downloader {
            handle: curl, header: HttpHeaders::new()
        }
    }

    /// Returns a mutable reference to the HTTP headers in order to modify them.
    pub fn headers_mut(&mut self) -> &mut HttpHeaders {
        &mut self.header
    }

    /// Tries to download the webpage at `uri` and returns a tuple containing
    /// the HTTP status code and the content of the webpage as string.
    ///
    /// # Arguments
    /// * `uri` - The URL to get the webpage from
    ///
    /// # Errors
    /// The function returns an error in the following cases:
    ///
    /// * the parameter `uri` is empty, does not start with "http://" or
    /// "https://" or `uri` starts with "https://", but curl does not support
    /// SSL
    /// * the underlying `curl` library returns an error
    /// * if the returned data cannot be successfully converted into an UTF-8
    /// string.
    pub fn download(&mut self, uri: &str) -> Result<(u32, String)> {
        if uri.is_empty() {
            return Err(Error::InvalidArgument("uri"));
        }

        if !uri.starts_with("http://") && !uri.starts_with("https://") {
            return Err(Error::GeneralError("This downloader only supports HTTP and HTTPS"));
        }

        if uri.starts_with("https://") && !curl::Version::get().feature_ssl() {
            return Err(Error::GeneralError("The underlying version of curl does not support SSL"));
        }

        let mut data = Vec::new();
        self.handle.url(uri)?;
        self.handle.http_headers(self.header.get_list()?)?;
        {
            let mut transfer = self.handle.transfer();
            transfer.write_function(|n_data| {
                data.extend_from_slice(n_data);
                Ok(n_data.len())
            })?;
            transfer.perform()?;
        }

        let code = self.handle.response_code()?;
        match str::from_utf8(data.as_slice()) {
            Ok(v)   => Ok((code, v.to_owned())),
            Err(e)  => Err(Error::ConversionError(e))
        }
    }
}


#[cfg(test)]
mod test {
    use super::*;
    static HTTPBIN: &'static str = "http://127.0.0.1:8000";

    #[test]
    fn headers_init() {
        let h = HttpHeaders::new();
        assert_eq!(h.length(), 0);
    }

    #[test]
    fn headers_add() {
        let mut h = HttpHeaders::new();
        h.set("key", "value");
        assert_eq!(h.length(), 1);
        h.set("key2", "value2");
        assert_eq!(h.length(), 2);
        h.set("key", "value3");
        assert_eq!(h.length(), 2);
    }

    #[test]
    fn headers_clear() {
        let mut h = HttpHeaders::new();
        h.set("key", "value");
        assert_eq!(h.length(), 1);
        h.clear();
        assert_eq!(h.length(), 0);
    }

    #[test]
    fn headers_get() {
        let mut h = HttpHeaders::new();
        h.set("key", "value");
        assert_eq!(h.get_header("key").unwrap(), "value");
        assert_eq!(h.get_header("keynotpresent").is_some(), false);
    }

    #[test]
    fn headers_get_list() {
        let mut h = HttpHeaders::new();
        h.set("key", "value");
        h.set("key2", "value2");
        let lst = h.get_list();
        assert!(lst.is_ok());
    }

     #[test]
    fn downloader_init() {
        let d = Downloader::new();
        assert_eq!(d.headers().length(), 0);
    }

    #[test]
    fn downloader_set_headers() {
        let mut d = Downloader::new();
        assert_eq!(d.headers().length(), 0);
        d.headers_mut().set("key", "value");
        d.headers_mut().set("key2", "value2");
        assert_eq!(d.headers().length(), 2);
        d.headers_mut().clear();
        assert_eq!(d.headers().length(), 0);
    }

    #[test]
    #[ignore]
    fn downloader_download_page() {
        let mut d = Downloader::new();
        let r = d.download(&format!("{}/{}", HTTPBIN, "base64/aGVsbG8gd29ybGQNCg%3D%3D"));
        assert!(r.is_ok());
        let r = r.unwrap();
        assert_eq!(r.0, 200);
        assert_eq!(r.1, "hello world\r\n");
    }

    #[test]
    #[ignore]
    fn downloader_download_teacup() {
        let mut d = Downloader::new();
        let r = d.download(&format!("{}/{}", HTTPBIN, "status/418"));
        assert!(r.is_ok());
        let r = r.unwrap();
        assert_eq!(r.0, 418);
        assert!(r.1.contains("teapot"));
    }

    #[test]
    #[ignore]
    fn downloader_download_cve() {
        let mut d = Downloader::new();
        let r = d.download("https://cve.circl.lu/api/cve/CVE-2018-11239");
        assert!(r.is_ok());
        let r = r.unwrap();
        assert_eq!(r.0, 200);
        assert!(r.1.contains("\"id\": \"CVE-2018-11239\","));
    }

}
